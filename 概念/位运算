位运算在许多古老的微处理器上，位运算比加减运算略快，通常位运算比乘除法运算要快很多。
在现代架构中，情况并非如此：位运算的运算速度通常与加法运算相同(仍然快于乘法运算)
当用a乘b，且如果b满足2^N的时候 就相当于把a的二进制数据向左移动N位,不足八位按0补齐
即:3*2 = (2^(1)+2 + 2^(0)) * 2^(1) = 00000011 * 00000010 = 00000110
3<<2 =  00000011 << 2^(1) = 00000011 0(补齐)

但当b不满足2^n的时候,将结果拆分为2^n次方后(可参考进制转换.txt),分别位移后进行相加
16*3 = > 16 * 2 + 16*1 = 2^(4) << 2^(1) + 2^(4) << 2^(0) = 00010000 << 1 + 00010000 << 0 = 00110000

除法和上面一样，不过是换成了向右移，但是是把右边的数移除后左边补0
即 16/2 = 00010000 / 2^(1) = 00010000 >> 1 = 00001000


原码:原码是指将最高位作为符号位(0表示正，1表示负)，其它数字位代表数值本身的绝对值的数字表示方式。
    16 = 00010000
   -16 = 10010000
反码:一个数如果为正，则它的反码与原码相同；一个数如果为负，则符号位为1，(符号位不变化，其余位数取反)。
    16 = 00010000
   -16 = 11101111(最高位表示符号位)
补码:补码：一个数如果为正，则它的原码、反码、补码相同；一个数如果为负，取到反码后加1
    16 = 00010000
   -16 = 11110000(最高位表示符号位)


课题之外:
为什么一个二进制是八位？？
所谓字节,原意就是用来表示一个完整的字符的。
最初的计算机性能和存储容量都比较差,所以普遍采用4位BCD编码(这个编码出现比计算机还早,最早是用在打孔卡上的)。
BCD编码表示数字还可以,但表示字母或符号就很不好用,需要用多个编码来表示。后来又演变出6位的BCD编码(BCDIC),以及至今仍在广泛使用的7位ASCII编码。
不过最终决定字节大小的,是大名鼎鼎的System/360(IBM设计的系统),当时IBM为System/360设计了一套8位EBCDIC编码,涵盖了数字、大小写字母和大部分常用符号,
同时又兼容广泛用于打孔卡的6位BCDIC编码。System/360很成功,也奠定了字符存储单位采用8位长度的基础,这就是1字节=8位的由来。